<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RTSP → WebRTC Viewer</title>
  <script defer>
    document.addEventListener("DOMContentLoaded", () => {
      console.log("DOMContentLoaded event fired.");
      const wsUrl = `ws://localhost:8080/ws`;
      const canvas = document.getElementById("remoteCanvas"); 
      const ctx = canvas.getContext("2d"); 
      const ws = new WebSocket(wsUrl);
      let pc;
      let videoDecoder;
      let videoDataChannel;

      ws.addEventListener("open", async () => {
        console.log("WebSocket connection opened.");
        try {
          pc = new RTCPeerConnection({
            iceServers: [
              // Googleの公開STUNサーバーを使用
              { urls: "stun:stun.l.google.com:19302" }
            ], 
            iceTransportPolicy: 'all',      // UDP 優先
            bundlePolicy: 'max-bundle',     // 1 つの流路にまとめる
            rtcpMuxPolicy: 'require'        // RTC 用ポートを共用
          });
          console.log("RTCPeerConnection created."); 

          // VideoDecoder の初期化
          if (!videoDecoder) {
            videoDecoder = new VideoDecoder({
              output: (videoFrame) => {
                console.log("VideoDecoder output:", videoFrame); 
                 if (canvas.width !== videoFrame.displayWidth || canvas.height !== videoFrame.displayHeight) {
                  canvas.width = videoFrame.displayWidth;
                  canvas.height = videoFrame.displayHeight;
                  console.log("Canvas resized to:", canvas.width, "x", canvas.height); 
                }
                ctx.drawImage(videoFrame, 0, 0, videoFrame.displayWidth, videoFrame.displayHeight);
                console.log("Drew frame to canvas:", videoFrame.timestamp); 
                videoFrame.close(); 
              },
              error: (err) => {
                console.error("VideoDecoder error:", err);
              }
            });

            try {
              videoDecoder.configure({
                codec: 'avc1.42e01f',
                optimizeForLatency: true,
                hardwareAcceleration: 'prefer-hardware'
              });
              console.log("VideoDecoder configured successfully.");
            } catch (err) {
              console.error("Failed to configure VideoDecoder:", err);
            }
          }

          videoDataChannel = pc.createDataChannel("videoNaluChannel", { ordered: false, maxRetransmits: 0,priority: 'high'  });
          console.log("videoDataChannel created:", videoDataChannel);

          videoDataChannel.onopen = () => {
            console.log("videoDataChannel 'videoNaluChannel' opened");
          };

          videoDataChannel.onclose = () => {
            console.log("videoDataChannel 'videoNaluChannel' closed");
          };

          videoDataChannel.onerror = (error) => {
            console.error("videoDataChannel 'videoNaluChannel' error:", error);
          };

          let pendingSPS, pendingPPS;

          let spsNal = null;
          let ppsNal = null;

          videoDataChannel.onmessage = ({ data }) => {
            if (typeof data !== 'string') return; 
            const msg = JSON.parse(data);
            const nalu = Uint8Array.from(atob(msg.data), c => c.charCodeAt(0));

            // 4 byte スタートコードを付けて Annex-B 形式で結合するヘルパー
            const annexB = (...nalus) => {
              const sc = new Uint8Array([0, 0, 0, 1]);
              const size = nalus.reduce((s, n) => s + 4 + n.length, 0);
              const buf  = new Uint8Array(size);
              let off = 0;
              for (const n of nalus) { buf.set(sc, off); off += 4; buf.set(n, off); off += n.length; }
              return buf;
            };

            switch (msg.type) {
              case 'sps':
                spsNal = nalu;
                return;
              case 'pps':
                ppsNal = nalu;
                return;
              case 'key': {
                if (!spsNal || !ppsNal) {
                  console.warn('SPS/PPS 未受信のままキーを受け取りました。スキップします');
                  return;
                }

                if (videoDecoder.state !== 'configured') {
                  videoDecoder.configure({
                    codec: 'avc1.42e01f',
                    optimizeForLatency: true,
                    hardwareAcceleration: 'prefer-hardware'
                  });
                }

                const au = annexB(spsNal, ppsNal, nalu);
                videoDecoder.decode(new EncodedVideoChunk({
                  type: 'key',
                  timestamp: msg.timestamp * 1000,
                  data: au,
                }));
                break;
              }
              case 'delta': {
                if (videoDecoder.state !== 'configured') return;
                videoDecoder.decode(new EncodedVideoChunk({
                  type: 'delta',
                  timestamp: msg.timestamp * 1000,
                  data: annexB(nalu),
                }));
                break;
              }
            }
          };

          pc.onicecandidateerror = (event) => {
            console.error("ICE candidate error event:", event);
            if (event.url && event.errorCode && event.errorText) {
              console.error(`ICE Candidate Error: URL=${event.url}, Code=${event.errorCode}, Text=${event.errorText}`);
            }
          };

          pc.oniceconnectionstatechange = (event) => {
            console.log(`ICE connection state changed: ${pc.iceConnectionState}`, event);
          };

          pc.ontrack = (e) => {
            console.log("pc.ontrack event:", e); 
            if (e.track.kind === 'audio') {
              console.log("Received audio track:", e.track);
            }
          };

          // ICE候補が見つかったらサーバーに送信
          pc.onicecandidate = ({ candidate }) => {
            if (candidate) {
              console.log("Sending ICE candidate:", candidate.candidate); 
              ws.send(JSON.stringify({ type: "candidate", candidate: candidate.candidate }));
            } else {
              console.log("All ICE candidates have been gathered and sent.");
            }
          };

          console.log("Creating offer...");
          const offer = await pc.createOffer({ offerToReceiveVideo: true }); 
          console.log("Offer created:", offer);         
          console.log("Setting local description with offer...");
          try {
            await pc.setLocalDescription(offer);
            console.log("Local description set successfully.");
            console.log("pc.localDescription after setLocalDescription:", pc.localDescription); 
            
            // オファーをサーバーに送信
            if (pc.localDescription && pc.localDescription.sdp) {
              console.log("▶️ pc.localDescription (final for offer):", pc.localDescription);
              console.log("▶️ pc.localDescription.sdp (final for offer):", pc.localDescription.sdp);
              const offerPayload = { type: "offer", sdp: pc.localDescription.sdp };
              const offerPayloadString = JSON.stringify(offerPayload);
              console.log("▶️ Offer payload to send (string):", offerPayloadString);
              
              if (offerPayloadString && offerPayloadString !== "{}") { 
                ws.send(offerPayloadString);
                console.log("Offer sent to server."); 
              } else {
                console.error("Offer payload string is empty or invalid. Not sending. Payload:", offerPayloadString);
              }
            } else {
               console.error("Local description or SDP is missing after setLocalDescription. Cannot send offer.");
            }

          } catch (err) {
            console.error("Error setting local description or sending offer:", err);
          }

        } catch (error) {
          console.error("Error in WebSocket 'open' handler:", error); 
        }
      });

      ws.addEventListener("message", async ({ data }) => {
        console.log("Raw message data from server:", data); 
        try {
          const msg = JSON.parse(data);
          console.log("◀️ Message from server (parsed):", msg); 
          if (msg.type === "answer") {
            console.log("✔️ Answer SDP:", msg.sdp);
            if (!msg.sdp) {
                console.error("Answer SDP is missing or empty.");
                return;
            }
            await pc.setRemoteDescription(
              new RTCSessionDescription({ type: "answer", sdp: msg.sdp })
            );
            console.log("Remote description (answer) set."); 
          } else if (msg.type === "candidate") {
            console.log("Received ICE candidate from server:", msg.candidate); 
            if (msg.candidate) { 
                await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); // Assuming msg.candidate is a valid RTCIceCandidateInit
            } else {
                console.warn("Received null or empty candidate from server.");
            }
          } else {
            console.warn("Received unknown message type from server:", msg.type);
          }
        } catch (error) {
          console.error("Error processing message from server:", error, "Raw data:", data);
        }
      });

      ws.addEventListener("error", (event) => {
        console.error("WebSocket error observed:", event); 
      });

      ws.addEventListener("close", (event) => {
        console.log("WebSocket connection closed. Code:", event.code, "Reason:", event.reason, "wasClean:", event.wasClean); 
      });
    });
  </script>
  <style>
    body { 
        background-color: #111827; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0;
    }
    canvas { 
        width: 100%; max-width: 64rem; border-radius: 1rem; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
    }
  </style>
</head>
<body>
  <canvas id="remoteCanvas"></canvas>
</body>
</html>